components
index.js
render root with app inside it
createStore()
thunk
action creator
reducer
hooks
useSelector
useDispatch
input field
onSubmit handler


Two ways to Apporach Writing a Fullstack Application
----------------------------------------------------

Pre-steps:
  - What features? What's the purpose/function of my features?
      --> Do I need CRUD? Which CRUD is necessary for this feature?


1. Backend
    -->

2. Frontend
    --> 1. Do I have the data accessible? (data from backend is complete)
    --> 2. Do I need REDUX for this/that feaure?
         --> If yes, REDUCER, CREATESTORE, USESELECTOR, ETC. will come into play-- REDUX BOILERPLATE
                --> Setup your index file, store directory, connect reducers
                       --> Move ONE FEATURE at a time
                            --> Which CRUD:
                                1. READ
                                3. CREATE
                                4. PUT
                                2. DELETE
                            For each particular CRUD, you'll need TYPE, ACTION CREATOR, THUNK, REDUCER
                                --> Is there any RESOURCES I can refer back to to help me?


EXAMPLE FOR SEARCH:
  - CRUD
      --> READ?
      --> POST/CREATE


Do I need REDUX?
    - Do I want my user to go back to a SAVED search?
    - Is my database so large that I'll need a big store for my data?


SPOTS PLANNING:
--------------------
0. Data able to be grabbed from backend?
    Yes, via csrfetch (❓1)
1. REDUX NEEDED? Yes.
    Create/Setup index.js and App.js file in src folder:
        --> Render App component inside of index.js
            --> Create a components directory (if not already made) and make new files as needed for Spots feature:
                1. SpotIndex.js (❓2)
                2. SpotShow.js (❓3)
            --> Create a STORE directory with an index.js file and spots.js file
                1. Have index.js file contain your COMBINE reducers
                2. Have spot.js contain all your CRUD actions and your SPOTreducer, i.e.:


                        const CREATE = 'spots/createSpot';  (❓4)

                        export const actionCreateSpot = (spot) => ({
                          type: CREATE,
                          spot
                        })


                    a. create a function 'defaultState' (this will grab your initial spot data from your seeders(❓5))
                    b. create a spotsReducer
                        --> the params of this function will be your CALLED defaultState set to a variable 'state' and an ACTION. See ex. below
                             * MAKE SURE TO MAKE A 'newState' AND SET IT TO YOUR DESTRUCTURED 'state'

                            Create switch/cases for your CRUD as well. Your spotsReducer should look something like this:


                                export default function spotsReducer(state = defaultState(), action){
                                  const newState = { ...state }

                                  switch(action.type){
                                    case CREATE:
                                      newState[action.spot.id] = action.spot
                                      return newState
                                    case DELETE:
                                      delete newState[action.id]
                                      return newState
                                    case RESET:
                                      return defaultState()
                                    default:
                                      return state
                                  }
                                }
(❓6) thunk?
(❓7) modals?


---------------------------------
(❓) QUESTIONS/CONFUSION POINTS FOOTNOTES:

    (1) Need a refresher on csrfetch and how it works

    (2 & 3)
        I was referencing code from the Reports long practice and saw they used these NAMES for their reports,
        as well as other names such as
        "ReportForm", "ReportIndexItem", "EditReportForm", "CreateReportForm" etc.
        but I don't understand why it's organized this way and how I should organize my own in a similar fashion
            (2) I assume this is the boilerplate code and hub for all spot stuff to be connected to
            (3) I assume this is where spots are going to be fetched and rendered
            ( ) Should I have another component js file for my spots?
                  -  I'm entirely lost on what other components I might make for it and WHEN TO KNOW when to make a new component

    (4) I'm confused as to why the syntax is like this
          -  Why is the 'type' key set to the CREATE key, set to a string of the route?

    (5) Unsure about this
    (6) When during all of this would thunk come into play?
    (7) I don't quite understamd what modals are/their function/purpose, so I don't even know when/where I would use them
----------------------------------







REVIEWS PLANNING (c+p from spots planning and edited):
--------------------
0. Data able to be grabbed from backend?
    Yes, via csrfetch
1. REDUX NEEDED? Yes.
    Create/Setup index.js and App.js file in src folder:
        --> Render App component inside of index.js
            --> Create a components directory (if not already made) and make new files as needed for Reviews feature:
                1. ReviewIndex.js
                2. ReviewShow.js
            --> Create a STORE directory with an index.js file and reviews.js file
                1. Have index.js file contain your reducers and your reviewReducer
                2. Have review.js contain all your CRUD actions, i.e.:


                        const CREATE = 'reviews/createReview';

                        export const actionCreateReview = (review) => ({
                          type: CREATE,
                          review
                        })


                    a. create a function 'defaultState'
                    b. create a reviewsReducer
                        --> the params of this function will be your CALLED defaultState set to a variable 'state' and an ACTION. See ex. below
                             * MAKE SURE TO MAKE A 'newState' AND SET IT TO YOUR DESTRUCTURED 'state'

                            Create switch/cases for your CRUD as well. Your reviewsReducer should look something like this:


                                export default function reviewsReducer(state = defaultState(), action){
                                  const newState = { ...state }

                                  switch(action.type){
                                    case CREATE:
                                      newState[action.review.id] = action.review
                                      return newState
                                    case DELETE:
                                      delete newState[action.id]
                                      return newState
                                    case RESET:
                                      return defaultState()
                                    default:
                                      return state
                                  }
                                }

useDispatch()
-------------------------
"The engine that drives redux" - Dan

It's the thing that gets everything going.

dispatch()
    --> thunk()
     --> Action creator()
      --> Will invoke ALL OF YOUR REDUCERS SEQUENTIALLY
       --> Will invoke your SELECTORS


(think of it like a middleware)
THUNK -- GETS DATA FROM AN API ROUTE and PASSES IT ONTO ITS ACTIONCREATOR

useSelector()
------------------------